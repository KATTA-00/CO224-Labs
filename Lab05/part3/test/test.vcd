$date
	Thu May 11 14:05:10 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module test_tb $end
$var wire 32 ! PC [31:0] $end
$var reg 1 " CLK $end
$var reg 32 # INSTRUCTION [31:0] $end
$var reg 1 $ RESET $end
$scope module CPU $end
$var wire 1 " CLK $end
$var wire 32 % INSTRUCTION [31:0] $end
$var wire 1 $ RESET $end
$var wire 32 & PC [31:0] $end
$scope module p $end
$var wire 1 " CLK $end
$var wire 1 $ RESET $end
$var wire 32 ' adder_out [31:0] $end
$var reg 32 ( PC [31:0] $end
$var reg 32 ) PC_NEXT [31:0] $end
$scope module pc_adder $end
$var wire 32 * PC [31:0] $end
$var wire 32 + adder_out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
bx +
b0 *
bx )
b0 (
bx '
b0 &
bx %
x$
bx #
0"
b0 !
$end
#1
b1 )
b1 '
b1 +
#5
1"
#6
b1 !
b1 &
b1 (
b1 *
#7
b10 )
b10 '
b10 +
#10
0"
#15
1"
#16
b10 !
b10 &
b10 (
b10 *
#17
b11 )
b11 '
b11 +
#20
0"
#25
1"
#26
b11 !
b11 &
b11 (
b11 *
#27
b100 )
b100 '
b100 +
#30
0"
